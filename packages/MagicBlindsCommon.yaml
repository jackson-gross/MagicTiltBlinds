# ============================================================================
# SUBSTITUTIONS
# ============================================================================
substitutions:
  name: "automated-tilt-blinds"
  friendly_name: "Tilt Blinds"
  project_name: "Jackson Gross.Smart Tilt Blinds"
  version: "1.0"

# ============================================================================
# DEVICE CONFIGURATION
# ============================================================================
esphome:
  on_boot:
    priority: -100
    then:
      # Restore last known position from flash
      - stepper.report_position:
          id: my_stepper
          position: !lambda 'return id(saved_position);'
      - cover.template.publish:
          id: my_blind
          position: !lambda 'return id(saved_position) / (float)id(max_position);'
      - if:
          condition:
            lambda: 'return !id(is_calibrated);'
          then:
            - logger.log: "Tilt not calibrated. Use 'Start Calibration' button or service."

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:
  level: INFO

# ============================================================================
# GLOBAL VARIABLES - Calibration & Position Storage
# ============================================================================
globals:
  - id: max_position
    type: int
    restore_value: yes
    initial_value: '2048'  # Default for 180° tilt - typical range 1500-3000 steps
  
  - id: saved_position
    type: int
    restore_value: yes
    initial_value: '1024'  # Start at middle (horizontal)
  
  - id: is_calibrated
    type: bool
    restore_value: yes
    initial_value: 'false'
  
  - id: calibration_step
    type: int
    initial_value: '0'  # 0=idle, 1=moving to extreme 1, 2=ready for extreme 2
  
  - id: calibration_time
    type: float
    restore_value: yes
    initial_value: '3.0'  # Seconds to run calibration in each direction


# ============================================================================
# API SERVICES
# ============================================================================
api:
  services:
    - service: control_tilt
      variables:
        target: int
      then:
        - stepper.set_target:
            id: my_stepper
            target: !lambda 'return target;'
        - lambda: |-
            id(saved_position) = target;
    
    - service: start_calibration
      then:
        - logger.log: "Starting tilt calibration..."
        - script.execute: calibrate_script
    
    - service: set_horizontal
      then:
        - stepper.set_target:
            id: my_stepper
            target: !lambda 'return id(max_position) / 2;'
    
    - service: set_tilt_extreme_1
      then:
        - stepper.report_position:
            id: my_stepper
            position: 0
        - globals.set:
            id: saved_position
            value: '0'
        - logger.log: "Current position set as EXTREME 1 (0 steps)"
    
    - service: set_tilt_extreme_2
      then:
        - globals.set:
            id: max_position
            value: !lambda 'return id(my_stepper).current_position;'
        - globals.set:
            id: is_calibrated
            value: 'true'
        - globals.set:
            id: saved_position
            value: !lambda 'return id(my_stepper).current_position;'
        - logger.log:
            format: "Current position set as EXTREME 2 (%d steps). Calibration complete!"
            args: ['id(my_stepper).current_position']
    
    - service: jog_tilt
      variables:
        steps: int
      then:
        - stepper.set_target:
            id: my_stepper
            target: !lambda 'return id(my_stepper).current_position + steps;'


# ============================================================================
# COVER ENTITY - Main Blind Control
# ============================================================================
cover:
  - platform: template
    name: "Blind Tilt"
    id: my_blind
    device_class: blind
    has_position: true
    optimistic: false
    
    lambda: |-
      if (id(max_position) == 0) return 0.5;
      return id(my_stepper).current_position / (float)id(max_position);
    
    position_action:
      - stepper.set_target:
          id: my_stepper
          target: !lambda |-
            int target = (int)(pos * id(max_position));
            return target;
      - delay: 100ms
    
    open_action:
      - logger.log: "Opening tilt to extreme 2 (tilted opposite direction)"
      - stepper.set_target:
          id: my_stepper
          target: !lambda 'return id(max_position);'
      - cover.template.publish:
          id: my_blind
          current_operation: OPENING
    
    close_action:
      - logger.log: "Closing tilt to extreme 1 (tilted one direction)"
      - stepper.set_target:
          id: my_stepper
          target: 0
      - cover.template.publish:
          id: my_blind
          current_operation: CLOSING
    
    stop_action:
      - logger.log: "Stopping tilt"
      - stepper.set_target:
          id: my_stepper
          target: !lambda 'return id(my_stepper).current_position;'
      - cover.template.publish:
          id: my_blind
          current_operation: IDLE


# ============================================================================
# CALIBRATION SCRIPT
# ============================================================================
script:
  - id: calibrate_script
    mode: restart
    then:
      - logger.log: "=== TILT CALIBRATION STARTED ==="
      - logger.log:
          format: "Using calibration time: %.1f seconds in each direction"
          args: ['id(calibration_time)']
      - globals.set:
          id: calibration_step
          value: '1'
      
      # Record the starting position
      - lambda: |-
          int start_pos = id(my_stepper).current_position;
          ESP_LOGI("calibrate", "Start position: %d", start_pos);
      
      # Move in one direction for the configured time
      - logger.log: "Step 1: Tilting to EXTREME 1..."
      - stepper.set_target:
          id: my_stepper
          target: -5000  # Large negative number to ensure continuous movement
      
      - delay: !lambda 'return (int)(id(calibration_time) * 1000);'
      
      # Stop and record this as position 0
      - stepper.set_target:
          id: my_stepper
          target: !lambda 'return id(my_stepper).current_position;'
      - delay: 500ms
      
      - stepper.report_position:
          id: my_stepper
          position: 0
      - globals.set:
          id: saved_position
          value: '0'
      
      - logger.log: "EXTREME 1 set to position 0"
      - logger.log: "Step 2: Tilting to EXTREME 2..."
      - globals.set:
          id: calibration_step
          value: '2'
      
      # Move in opposite direction for the same configured time
      - stepper.set_target:
          id: my_stepper
          target: 5000  # Large positive number to ensure continuous movement
      
      - delay: !lambda 'return (int)(id(calibration_time) * 1000);'
      
      # Stop and record max position
      - stepper.set_target:
          id: my_stepper
          target: !lambda 'return id(my_stepper).current_position;'
      - delay: 500ms
      
      # Save the max position
      - globals.set:
          id: max_position
          value: !lambda 'return id(my_stepper).current_position;'
      - globals.set:
          id: is_calibrated
          value: 'true'
      - globals.set:
          id: calibration_step
          value: '0'
      
      - logger.log:
          format: "=== CALIBRATION COMPLETE === Range: 0 to %d steps"
          args: ['id(max_position)']
      
      # Move to horizontal (middle) position for maximum light
      - logger.log: "Moving to horizontal position (50%%) for maximum light..."
      - delay: 1s
      - stepper.set_target:
          id: my_stepper
          target: !lambda 'return id(max_position) / 2;'
      
      - delay: !lambda 'return (int)((id(calibration_time) / 2.0 + 0.5) * 1000);'
      
      - globals.set:
          id: saved_position
          value: !lambda 'return id(my_stepper).current_position;'
      - logger.log: "Calibration finished! Blinds at 50% (horizontal)"


# ============================================================================
# SENSORS - Position & Status Monitoring
# ============================================================================
sensor:
  # Position Sensors
  - platform: template
    name: "Tilt Position Steps"
    id: position_steps
    unit_of_measurement: "steps"
    accuracy_decimals: 0
    update_interval: 1s
    lambda: |-
      return id(my_stepper).current_position;
  
  - platform: template
    name: "Tilt Position Percent"
    id: position_percent
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: 1s
    lambda: |-
      if (id(max_position) == 0) return 0;
      float percent = (id(my_stepper).current_position * 100.0) / id(max_position);
      return percent;
  
  - platform: template
    name: "Tilt Angle Estimate"
    id: tilt_angle
    unit_of_measurement: "°"
    accuracy_decimals: 0
    update_interval: 1s
    lambda: |-
      if (id(max_position) == 0) return 0;
      // Estimate: 0° = one extreme, 90° = horizontal, 180° = opposite extreme
      float angle = (id(my_stepper).current_position * 180.0) / id(max_position);
      return angle;
  
  - platform: template
    name: "Distance from Horizontal"
    id: distance_horizontal
    unit_of_measurement: "°"
    accuracy_decimals: 0
    update_interval: 1s
    lambda: |-
      if (id(max_position) == 0) return 0;
      // Show how far from horizontal (90°) position
      float angle = (id(my_stepper).current_position * 180.0) / id(max_position);
      return abs(angle - 90.0);
  
  # System Sensors
  - platform: wifi_signal
    name: "Blind WiFi Signal"
    update_interval: 60s
  
  - platform: uptime
    name: "Blind Uptime"


# ============================================================================
# TEXT SENSORS - Status & Descriptions
# ============================================================================
text_sensor:
  - platform: template
    name: "Tilt Calibration Status"
    id: calibration_status
    update_interval: 2s
    lambda: |-
      if (id(calibration_step) == 1) {
        return {"Calibrating: Moving to extreme position 1..."};
      } else if (id(calibration_step) == 2) {
        return {"Calibrating: Press 'Set Extreme 2' at opposite limit"};
      } else if (id(is_calibrated)) {
        char buf[70];
        sprintf(buf, "Calibrated (0 to %d steps, 180° range)", id(max_position));
        return {buf};
      } else {
        return {"Not Calibrated - Press 'Start Calibration'"};
      }
  
  - platform: template
    name: "Tilt Position Description"
    id: position_description
    update_interval: 2s
    lambda: |-
      if (id(max_position) == 0) return {"Unknown"};
      float angle = (id(my_stepper).current_position * 180.0) / id(max_position);
      
      if (angle < 10) {
        return {"Extreme 1 - Tilted fully one direction"};
      } else if (angle > 170) {
        return {"Extreme 2 - Tilted fully opposite direction"};
      } else if (angle > 80 && angle < 100) {
        return {"Horizontal - Maximum light (90°)"};
      } else if (angle < 90) {
        char buf[50];
        sprintf(buf, "Tilted toward Extreme 1 (%.0f°)", angle);
        return {buf};
      } else {
        char buf[50];
        sprintf(buf, "Tilted toward Extreme 2 (%.0f°)", angle);
        return {buf};
      }


# ============================================================================
# BUTTONS - Calibration & Control
# ============================================================================
button:
  # Calibration Buttons
  - platform: template
    name: "Start Calibration"
    id: start_calibration_button
    entity_category: config
    on_press:
      - script.execute: calibrate_script
  
  - platform: template
    name: "Set Extreme 1"
    id: set_extreme_1_button
    entity_category: config
    on_press:
      - stepper.report_position:
          id: my_stepper
          position: 0
      - globals.set:
          id: saved_position
          value: '0'
      - logger.log: "Current position marked as EXTREME 1"
  
  - platform: template
    name: "Set Extreme 2"
    id: set_extreme_2_button
    entity_category: config
    on_press:
      - globals.set:
          id: max_position
          value: !lambda 'return id(my_stepper).current_position;'
      - globals.set:
          id: is_calibrated
          value: 'true'
      - globals.set:
          id: calibration_step
          value: '0'
      - logger.log:
          format: "Current position marked as EXTREME 2 (%d steps). Calibrated!"
          args: ['id(my_stepper).current_position']
  
  # Position Control Buttons
  - platform: template
    name: "Go Fully Down (0%)"
    id: go_closed
    on_press:
      - stepper.set_target:
          id: my_stepper
          target: 0
      - logger.log: "Moving to fully closed position (0%)"
  
  - platform: template
    name: "Go to Horizontal (Max Light)"
    id: go_horizontal
    on_press:
      - stepper.set_target:
          id: my_stepper
          target: !lambda 'return id(max_position) / 2;'
      - logger.log: "Moving to horizontal position (50%) for maximum light"
  
  - platform: template
    name: "Go Fully Up (100%)"
    id: go_open
    on_press:
      - stepper.set_target:
          id: my_stepper
          target: !lambda 'return id(max_position);'
      - logger.log: "Moving to fully open position (100%)"
  
  # Jog Buttons
  - platform: template
    name: "Jog Open 150 Steps"
    id: jog_forward
    entity_category: config
    on_press:
      - stepper.set_target:
          id: my_stepper
          target: !lambda 'return id(my_stepper).current_position + 150;'
  
  - platform: template
    name: "Jog Close 150 Steps"
    id: jog_backward
    entity_category: config
    on_press:
      - stepper.set_target:
          id: my_stepper
          target: !lambda 'return id(my_stepper).current_position - 150;'
  
  # System Button
  - platform: restart
    name: "Restart Blind Controller"


# ============================================================================
# NUMBER INPUTS - Configuration
# ============================================================================
number:
  - platform: template
    name: "Calibration Time"
    id: calibration_time_config
    entity_category: config
    min_value: 1.0
    max_value: 10.0
    step: 0.5
    initial_value: 3.0
    optimistic: true
    restore_value: true
    unit_of_measurement: "s"
    mode: slider
    on_value:
      then:
        - globals.set:
            id: calibration_time
            value: !lambda 'return x;'
        - logger.log:
            format: "Calibration time set to %.1f seconds per direction"
            args: ['x']


# ============================================================================
# SWITCHES - LED & Attem
# ============================================================================
switch:
  - platform: gpio
    pin: GPIO2
    id: status_led
    inverted: true
    internal: true
  
  - platform: template
    name: "Enable Movement LED"
    id: movement_led_enabled
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON


# ============================================================================
# INTERVALS - LED Blink & Position Updates
# ============================================================================
interval:
  # LED Indicator
  - interval: 300ms
    then:
      - if:
          condition:
            and:
              - lambda: 'return id(movement_led_enabled).state;'
              - lambda: 'return id(my_stepper).current_position != id(my_stepper).target_position;'
          then:
            - switch.toggle: status_led
          else:
            - switch.turn_off: status_led
  
  # Position Tracking & State Updates
  - interval: 500ms
    then:
      - lambda: |-
          static int last_saved = 0;
          int current = id(my_stepper).current_position;
          
          // Save position every 50 steps to reduce flash wear
          if (abs(current - last_saved) >= 50) {
            id(saved_position) = current;
            last_saved = current;
          }
          
          // Always update cover position based on current stepper position
          if (id(max_position) > 0) {
            float pos = (float)current / (float)id(max_position);
            id(my_blind).position = pos;
            id(my_blind).publish_state();
          }
          
          // Update operation state
          if (current != id(my_stepper).target_position) {
            if (current < id(my_stepper).target_position) {
              id(my_blind).current_operation = COVER_OPERATION_OPENING;
            } else {
              id(my_blind).current_operation = COVER_OPERATION_CLOSING;
            }
          } else {
            id(my_blind).current_operation = COVER_OPERATION_IDLE;
          }
          id(my_blind).publish_state();
